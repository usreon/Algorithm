
# 문제
정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.
버블 정렬(bubble sort)은 여러 정렬 알고리즘(삽입 정렬, 퀵 정렬, 병합 정렬, 기수 정렬 등) 중 가장 기본적인 알고리즘입니다.


## 주의 사항
+ arr.sort 사용은 금지됩니다.
+ 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.


## 입출력 예시
+ 인자 1 : arr
    - number 타입을 요소로 갖는 배열
    - arr[i]는 정수
    - arr[i]의 길이는 1,000 이하
+ 출력
    - number 타입을 요소로 갖는 배열을 리턴해야 합니다.  
    - 배열의 요소는 오름차순으로 정렬되어야 합니다.
    - arr[i] <= arr[j] (i < j)

```js
let output = bubbleSort([2, 1, 3]);
console.log(output); // --> [1, 2, 3]
```

## 문제 풀이
배열의 앞에서부터 차례대로 정렬한다. 인자로 받은 배열을 반복문으로 돌아 i(인덱스)가 0일 때 i번째 요소가 i+1번째 요소보다 크면 두 요소의 위치를 바꾼다. 이 과정을 배열의 크기만큼 반복해야 되기 때문에 이중 반복문을 쓴다. 


## Code

```js
const bubbleSort = function (arr) {
  let temp;
  let swap = 0;

  for(let i=0; i<arr.length-1; i++) {
    for(let j=0; j<arr.length-1-i; j++) {
      if(arr[j]>arr[j+1]) {
        temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
        swap++
      }
    }
    if(swap === 0) {
      break;
    }
  }
  return arr;
}

// [5,4,3,2,1] => [1,2,3,4,5]

// i=0
// j=0
// [4,5,3,2,1]
// j=1
// [4,3,5,2,1]
// j=2
// [4,3,2,5,1]
// j=3
// [4,3,2,1,5] 
// 길이는 5여도 반복은 4번밖에 안 돈다 마지막 인덱스는 i+1와 비교해줄 수 없기 때문이다
// 따라서 조건문은 i < arr.length-1

// 이 과정을 한 번 더 한다
// i=1
// j=0
// [3,4,2,1,5]
// j=1
// [3,2,4,1,5]
// j=2
// [3,2,1,4,5]
// 두 번째 반복시 3번 반복했다 
// 세 번째 반복시 2번 반복되고 
// 네 번째 반복시 1번 반복되고 끝난다
// 따라서 반복문 설정시 j < arr.length-1-i 해준다

// 배열이 정렬되있는 경우 반복문을 돌 필요가 없다 

```

# 비고
배열의 어떤 요소도 위치가 바뀌지 않은 경우 배열이 정렬된 상태라는 것을 알 수 있다. <br>
따라서 배열의 요소가 바뀔 때만 변수를 설정하여 값이 증가하게 해주고, 조건문으로 그 변수의 값이 0일 댄 반복문을 종료해주는 구문을 작성해준다. 문제를 풀 때 break를 써서 수행 시간을 단축하는 방법에 대해서 생각해보자.