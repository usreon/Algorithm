# 문제
N * N의 크기를 가진 보드판 위에서 게임을 하려고 합니다. 게임의 룰은 다음과 같습니다.

좌표 왼쪽 상단(0, 0)에 말을 놓는다.
말은 상, 하, 좌, 우로 이동할 수 있고, 플레이어가 조작할 수 있다.
조작의 기회는 딱 한 번 주어지며, 최대 N * 2 번까지 이동할 수 있다.
조작할 때 U, D, L, R은 각각 상, 하, 좌, 우를 의미하며 한 줄에 띄어쓰기 없이 써야 한다.
예시: UDDLLRRDRR, RRRRR
한 번 움직일 때마다 한 칸씩 움직이게 되며, 그 칸 안의 요소인 숫자를 획득할 수 있다.
방문한 곳을 또 방문해도 숫자를 획득할 수 있다.
보드 밖을 나간 말은 OUT 처리가 된다.
칸 안의 숫자는 0 또는 1이다.
단, 좌표 왼쪽 상단(0, 0)은 항상 0이다.
획득한 숫자를 합산하여 숫자가 제일 큰 사람이 이기게 된다.
보드판이 담긴 board와 조작하려고 하는 문자열 operation이 주어질 때, 말이 해당 칸을 지나가면서 획득한 숫자의 합을 구하는 함수를 작성하세요.



## 주의 사항
만약, 말이 보드 밖으로 나갔다면 즉시 OUT 을 반환합니다.



## 입출력 예시
```js
const board1 = [
  [0, 0, 0, 1],
  [1, 1, 1, 0],
  [1, 1, 0, 0],
  [0, 0, 0, 0]
]
const output1 = boardGame(board1, 'RRDLLD');
console.log(output1); // 4
```



## 문제 풀이
board의 요소에 접근하기 위해서 [i][j]가 필요하다. 따라서 i, j를 담아주는 배열 하나를 만들어주고 시작점은 [0][0]이니까 값은 [0, 0]로 설정한다. position = [0,0] 일 때 board[position[0]][position[1]]로 접근할 수 있다. 디렉션을 설정해준다. U와 D일 때는 높이와 관계있는 행의 변화가 일어난다. 따라서 position[0]값이 변한다. L, R 일 때는 열의 변화가 일어난다. 따라서 position[1]값이 변화한다. 해당 칸을 지나가면서 획득한 숫자의 합을 담아주는 변수를 설정하고 board[position[0]][position[1]] === 1일 때마다 1씩 더해지도록 한다. 말이 보드 밖으로 나갈 때를 고려하여 if문을 작성하고 OUT을 리턴한다. 마지막으로 숫자의 합을 담아주는 변수를 리턴한다.



## Code

```js
function boardGame(board, operation) {
    let position = [0, 0];
    let sum = 0;

    // operation에 따른 디렉션 먼저 설정
    for(const word of operation) {
      // U, D는 행의 변화 position[0]
      if(word === 'U') {
        position[0] --;
      }
      if(word === 'D') {
        position[0] ++;
      }
      // L, R은 열의 변화 position[1]
      if(word === 'L') {
        position[1] --;
      }
      if(word === 'R') {
        position[1] ++;
      }

      if (position[0] < 0 || position[0] > board.length - 1 || position[1] > board[0].length - 1 || position[1] < 0) {
        return 'OUT';
      }
      
      else if(board[position[0]][position[1]] === 1) {
        sum ++;
      }
    }
  return sum;
};
```

## 비고
+ 이차원 배열 + 그 요소에 접근해야 되는 문제를 보면 파블로프의 개처럼 이중 반복문을 써야 된다는 생각이 든다.. 하지만 이번 문제는 배열을 반복문으로 돌아서 푸는 게 최선이 아닐 뿐더러 반복문 없이도 이차원 배열의 요소에 접근할 수 있었다. 생각없이 반복문부터 돌지 말고 필요한 코드와 불필요한 코드가 뭔지 생각해보자.
+ a = [[1,2,3],[4,5,6]], b = [0,0] ---> a[b[0]][b[1]] 로 접근할 수 있다. a[i][j] 여기서 i === b[0], j === b[1] 인 것 뿐이다.
+ 말이 보드 밖으로 나갔다면? 행의 값 position[0]이 0보다 작을 때, 열의 값 position[1]이 0보다 작을 때, 행의 값이 배열의 길이보다 길 때, 열의 값이 배열안의 배열 길이보다 길 때이다. 